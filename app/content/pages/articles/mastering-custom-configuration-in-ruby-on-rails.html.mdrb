---
title: Mastering Custom Configuration in Ruby on Rails
author: Ross Kaffenberger
layout: article
summary: Here is the summary
description: Here is the description that will show up in the the meta day
published: '2024-10-17'
uuid: 476af131-561e-408e-80fb-8daa64592677
image: articles/mastering-custom-configuration-in-ruby-on-rails/placeholder.jpg
meta_image: articles/mastering-custom-configuration-in-ruby-on-rails/placeholder.jpg
tags:
  - Rails
---

As your Ruby on Rails application grows, managing configuration becomes crucial for maintaining flexibility, security, and ease of deployment across different environments. Rails provides powerful built-in tools for handling custom configuration, allowing you to keep your code clean, maintainable, and environment-specific. In this comprehensive guide, we'll explore the ins and outs of custom configuration in Rails, from basic usage to advanced techniques.

## Understanding Rails Configuration

At its core, Rails configuration is about managing various settings that control how your application behaves in different environments. These settings can include database connections, API keys, feature flags, and much more. Effective use of configuration allows you to:

1. Keep environment-specific settings separate from your code
2. Manage feature flags and toggles
3. Store sensitive data (like API keys) securely
4. Make your application more maintainable and flexible

## Rails Built-in Configuration Methods

Rails provides two primary methods for handling custom configuration: the `config.x` namespace and the `config_for` method. Both of these utilize `ActiveSupport::OrderedOptions` under the hood.

### Using Rails.configuration.x Namespace

The `config.x` namespace, introduced in Rails 4.2, offers a clean and consistent interface for storing custom configuration settings. Here's how to use it:

```ruby
# config/application.rb
module YourApp
  class Application < Rails::Application
    # Simple string configuration
    config.x.payment_gateway.merchant_id = 'ABC123'

    # Boolean configuration for feature toggles
    config.x.features.enable_new_ui = true

    # Numeric configuration with type casting
    config.x.rate_limiting.max_requests = ENV.fetch('MAX_REQUESTS', '100').to_i

    # Logic in configuration
    config.x.cache.ttl = Rails.env.production? ? 1.hour : 5.minutes

    # Complex configuration with default values
    config.x.analytics.provider = ENV.fetch('ANALYTICS_PROVIDER', 'google')
    config.x.analytics.enabled = ActiveModel::Type::Boolean.new.cast(ENV.fetch('ANALYTICS_ENABLED', 'true'))
  end
end
```

You can then access these settings anywhere in your application:

```ruby
class PaymentsController < ApplicationController
  def create
    gateway = PaymentGateway.new(
      merchant_id: Rails.configuration.x.payment_gateway.merchant_id
    )

    # Use feature toggle
    if Rails.configuration.x.features.enable_new_ui
      render 'new_payment_form'
    else
      render 'legacy_payment_form'
    end
  end
end

class AnalyticsService
  def self.track(event)
    return unless Rails.configuration.x.analytics.enabled

    provider = Rails.configuration.x.analytics.provider
    # Use the provider to track the event
  end
end
```

The `config.x` namespace provides several benefits:

1. **Consistent Interface**: The `config.x` namespace provides a consistent way to access custom configuration throughout your application. This replaces the need to mix ENV variables, Rails credentials, and other methods of storing configuration data, leading to cleaner and more maintainable code.

2. **Logic and Type Casting**: You can apply logic and type casting to your custom configuration during Rails initialization. This ensures that your configuration values are of the correct type and format when your application code accesses them.

3. **Namespace Organization**: The `x` namespace allows you to organize your configuration settings into logical groups, improving readability and maintainability.

4. **Environment-Specific Overrides**: You can easily set different values for different environments, all within the Rails configuration structure.

5. **Testability**: Having a centralized configuration makes it easier to stub or mock configuration values in your tests.

### Loading Configuration from YAML Files

For more complex configurations, Rails provides the `config_for` method to load settings from YAML files:

```yaml
# config/analytics.yml
shared:
  enabled: true

development:
  provider: 'local'
  sampling_rate: 100

production:
  provider: 'google'
  sampling_rate: 10
  property_id: 'UA-XXXXXXXX-X'
```

Load the configuration in your application:

```ruby
# config/application.rb
module YourApp
  class Application < Rails::Application
    config.analytics = config_for(:analytics)
  end
end
```

Now you can access the configuration anywhere:

```ruby
Rails.configuration.analytics[:enabled]
Rails.configuration.analytics[:provider]
```

## Practical Use Cases

Let's explore some practical use cases for custom configuration in Rails applications.

### Feature Toggles

Feature toggles allow you to enable or disable features based on the environment:

```ruby
# config/environments/development.rb
Rails.application.configure do
  config.x.features.enable_beta = true
  config.x.features.enable_api_v2 = true
end

# config/environments/production.rb
Rails.application.configure do
  config.x.features.enable_beta = false
  config.x.features.enable_api_v2 = false
end

# Usage in controllers or views
if Rails.configuration.x.features.enable_beta
  # Render beta feature
end
```

### External Service Configuration

When working with external services, you often need different settings for development and production:

```yaml
# config/smtp.yml
development:
  address: 'localhost'
  port: 1025
  domain: 'localhost.test'

production:
  address: 'smtp.sendgrid.net'
  port: 587
  domain: 'yourdomain.com'
  user_name: <%= ENV['SENDGRID_USERNAME'] %>
  password: <%= ENV['SENDGRID_PASSWORD'] %>
```

```ruby
# config/application.rb
module YourApp
  class Application < Rails::Application
    config.action_mailer.smtp_settings = config_for(:smtp)
  end
end
```

### Multi-tenant Settings

For applications serving multiple clients, you might need client-specific configurations:

```yaml
# config/client_settings.yml
default: &default
  timeout: 30
  max_attempts: 3

client_a:
  <<: *default
  api_key: 'client_a_key'
  subdomain: 'client-a'

client_b:
  <<: *default
  api_key: 'client_b_key'
  subdomain: 'client-b'
  timeout: 60 # Override default
```

```ruby
# app/models/client.rb
class Client < ApplicationRecord
  def settings
    @settings ||= Rails.application.config_for(:client_settings)[subdomain.to_sym]
  end
end

# Usage
client = Client.find_by(subdomain: 'client-a')
client.settings[:api_key]    # => 'client_a_key'
client.settings[:timeout]    # => 30
```

## The Secret Sauce: ActiveSupport::OrderedOptions

Now that we've explored some practical use cases, let's dive deeper into `ActiveSupport::OrderedOptions`, the underlying mechanism that powers much of Rails' configuration functionality.

`ActiveSupport::OrderedOptions` is a subclass of `Hash` that allows you to access keys as methods. This is what enables the intuitive and flexible configuration syntax in Rails.

Key points about `OrderedOptions`:

1. It's used extensively in Rails' default configurations (e.g., `config.action_mailer`, `config.active_record`).
1. `config.x` lazily initializes an instance of `OrderedOptions` for each namespace.
1. `config_for` returns an instance of `OrderedOptions`.
1. You can create your own `OrderedOptions` instances for custom configurations.

Here's a closer look at how `OrderedOptions` works:

```ruby
require 'active_support/ordered_options'

config = ActiveSupport::OrderedOptions.new

# Set values using hash syntax or method calls
config[:api_key] = '12345'
config.max_users = 100

# Access values using hash syntax or method calls
puts config[:api_key]  # Output: 12345
puts config.max_users  # Output: 100

# Check for key existence
puts config.has_key?(:api_key)  # Output: true

# Nested configurations
config.database = ActiveSupport::OrderedOptions.new
config.database.username = 'admin'
config.database.password = 'secret'

puts config.database.username  # Output: admin
```

`OrderedOptions` provides several enhancements over regular Hashes:

1. **Method-like Access**: As shown above, you can access keys as if they were methods.

1. **Default Values**: Provide default values when a key is not found:

   ```ruby
   puts config.fetch(:timeout, 30)  # Output: 30 (if :timeout is not set)
   ```

1. **Raising Exceptions for Blank Values**: One powerful feature of `OrderedOptions` is the ability to raise an exception when accessing a value that is `nil` or blank by adding a `!` to the end of the method name. This is particularly useful for catching configuration errors early:

   ```ruby
   config = ActiveSupport::OrderedOptions.new
   config.required_api_key = ''

   # This will raise an ActiveSupport::OrderedOptions::MissingKeyError exception
   config.required_api_key!
   ```

   This feature is incredibly useful for validating that all required configuration values are properly set, especially for critical settings like API keys or database credentials. By raising an exception early, you can prevent your application from running with incomplete or invalid configuration, which could lead to errors or unexpected behavior later on.

   You can use this in your application code like this:

   ```ruby
   class ApiClient
     def initialize
       @api_key = Rails.configuration.x.api.key!
     end

     # rest of the class implementation
   end
   ```

   In this example, if the API key is not set or is blank, an exception will be raised when initializing the `ApiClient`, making it immediately clear that a crucial configuration is missing.

1. **Dynamic Generation**: You can use the `method_missing` magic to dynamically generate nested configurations:

   ```ruby
   config.nested = ActiveSupport::OrderedOptions.new
   config.nested.key # Output: nil
   config.nested.key = 'value'
   puts config.nested.deeply.nested.key  # Output: value
   ```

Understanding `OrderedOptions` is key to mastering Rails configuration, as it's used extensively throughout the framework, including in the `config.x` namespace and the `config_for` method.

## Best Practices for Rails Configuration

To make the most of Rails configuration, consider these best practices:

1. **Use Rails credentials for Sensitive Data**: Never commit sensitive information in plain text directly in application files. Use Rails credentials instead.

   ```sh
   bin/rails credentials:edit
   ```

   ```yaml
   aws:
     access_key_id: YOUR_ACCESS_KEY_ID
     secret_access_key: YOUR_SECRET_ACCESS_KEY_ID
   ```

I plan to write more about using Rails credentials in a future article. You can also see [the Rails guides](https://guides.rubyonrails.org/security.html#environmental-security) for more info.

1. **Namespace Your Configurations**: Keep your configurations organized by using namespaces.

   ```ruby
   config.x.payment_gateway.timeout = 30
   config.x.payment_gateway.retries = 3

   config.x.api.version = 'v1'
   config.x.api.base_url = 'https://api.example.com'
   ```

1. **Use Strong Typing**: Convert string values to appropriate types when possible.

   ```ruby
   config.x.analytics.enabled = ActiveModel::Type::Boolean.new.cast(ENV.fetch('ANALYTICS_ENABLED', 'true'))
   ```

1. **Leverage Rails Environments**: Utilize Rails' built-in environment-specific configuration files for settings that vary between environments.

1. **Validate Configuration**: Implement validation for your configuration values to catch errors early.

## Rails Configuration vs. Third-Party Gems

While Rails provides robust built-in options for custom configuration, some developers opt for third-party gems like

- [figaro](https://github.com/laserlemon/figaro),
- [rails-settings-cached](https://github.com/huacnlee/rails-settings-cached),
- [rubyconfig](https://github.com/rubyconfig/config),
- [fittings](https://github.com/stitchfix/fittings).

If you like these gems, feel free to use them! There‘s nothing wrong with using third-party gems for custom configuration, especially if you want the extra features they provide.

Just consider that using Rails built-in custom configuration features means:

- No Additional Dependencies: You don’t _have_ to add gems for custom configuratio thus reducing your maintenance burden and keep your dependency list lean.
- Consistency with Rails Conventions: Using Rails' built-in methods keeps your configuration consistent with other Rails conventions, making it easier for Rails developers to understand and maintain.

### When to Consider Third-Party Gems

1. **Complex Hierarchies**: For deeply nested configuration structures.
2. **Additional Features**: If you need features like automatic reloading or advanced validations.
3. **Cross-Framework Compatibility**: For consistency across multiple frameworks or pure Ruby applications.
4. **Specific Requirements**: When a gem offers features that align perfectly with your project's unique needs.

When choosing between Rails' built-in configuration and a third-party gem, consider your project's size, complexity, team familiarity, and specific feature requirements.

## Conclusion

Mastering custom configuration in Ruby on Rails allows you to build more flexible, maintainable, and environment-aware applications. By leveraging `ActiveSupport::OrderedOptions`, the `config.x` namespace, and `config_for`, you can create powerful and intuitive configuration systems for your Rails projects.

Custom configuration in Rails provides a powerful way to manage your application's settings across different environments. Whether you're using the simple `config.x` namespace or loading complex configurations from YAML files, Rails has you covered. By following best practices and choosing the right approach for your needs, you can keep your application's configuration clean, maintainable, and secure.

Remember to follow best practices, choose the right tools for your specific needs, and always prioritize security when dealing with sensitive configuration data. With these techniques and considerations in mind, you'll be well-equipped to handle even the most complex configuration requirements in your Rails applications.

Remember to always keep sensitive data out of your configuration files and use environment variables instead. With these tools and practices in hand, you're well-equipped to handle any configuration needs your Rails application might have.
